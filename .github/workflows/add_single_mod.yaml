name: Add single mod and all dependencies

on:
  workflow_dispatch:
    inputs:
      projectid:
        description: 'Write projetcId of mod'
        required: true
        default: '431168' 
        # default: '876781' Just mod
        type: string
      fileid: 
        description: 'Write modId of mod'
        required: true
        default: '5011582'
        type: string
      excluded_mods: 
        description: 'Write modId of mod that should be excluded (1, 2, 3 input format)'
        required: false
        default: '245506,298744,298965,231868,64578'
        type: string
      start_server: 
        description: 'Start server after installation?'
        required: false
        default: false 
        type: boolean
env:
  BASE_URL: https://api.curseforge.com
  MAX_PAGE_SIZE: 50
  API_KEY: \$2a\$10\$4UughKvVMNC9Yl0cUfhAsOiOkCWgy/k/6rn.z5bIztd62LpZ1eibe

jobs:
  download_and_install_mods:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v2

      - name: Set up SSH agent
        uses: webfactory/ssh-agent@v0.5.3
        with:
          ssh-private-key: ${{ secrets.SSH_DO_DROPLET }}

      - name: Create environment file
        run: |
          INPUT_PROJECT_ID=${{ github.event.inputs.projectid }}
          INPUT_FILE_ID=${{ github.event.inputs.fileid }}
          INPUT_EXLUDED_MODS=${{ github.event.inputs.excluded_mods }}
          echo "BASE_URL=$BASE_URL" > .env
          echo "API_KEY=$API_KEY" >> .env
          echo "MAX_PAGE_SIZE=$MAX_PAGE_SIZE" >> .env
          echo "INPUT_PROJECT_ID=$INPUT_PROJECT_ID" >> .env
          echo "INPUT_FILE_ID=$INPUT_FILE_ID" >> .env
          echo "INPUT_EXLUDED_MODS=$INPUT_EXLUDED_MODS" >> .env
          cat .env  

      - name: Copy .env file to Droplet
        run: |
          scp -o StrictHostKeyChecking=no .env root@206.189.84.101:/root/

      - name: Fetch main mod and recursive fetch deps
        run: |
         ssh -o StrictHostKeyChecking=no root@206.189.84.101 <<'EOF'
          fetch_with_dlink() {
            local url=$1

            downloadUrl=$(curl "$url" -H "x-api-key: $API_KEY" | sed '/HTTP_STATUS:/d' | jq -r '.data')
            echo "Extracted URL: $downloadUrl"

            fileName=$(basename "$downloadUrl")
            echo "fileName: $fileName"
          
            if [[ $downloadUrl =~ ^https?:// ]]; then
              echo "Valid URL: $downloadUrl"
              pathForFile="/root/temp/$fileName"
              curl -o "$pathForFile" -L "$downloadUrl"
              echo "Downloaded dep: $downloadUrl"
            else
              echo "Invalid URL extracted: $downloadUrl"
              exit 1
            fi
          }
          process_dependency() {
            local dep=$1
            local gameVersionFromMainMod=$2

              echo "Downloading dep: $dep"
              forgeGameVersion="Forge"
              modId=$(echo "$dep" | jq -r '.modId')
              relationType=$(echo "$dep" | jq -r '.relationType')
              api_url_mod_files="$BASE_URL/v1/mods/$modId/files"
              curl -L "$api_url_mod_files" -H "x-api-key: $API_KEY" -o /root/temp/response_dep.json

              echo "Checking for compatible dependency"
              jq -c -r '.data[]' /root/temp/response_dep.json | while IFS= read -r versionInfo; do
                if echo "$versionInfo" | jq -e --arg forge "$forgeGameVersion" --arg gameVersion "$gameVersionFromMainMod" '.gameVersions | index($forge) and index($gameVersion)' >/dev/null; then
                  echo "Downloading dependency for $forgeGameVersion and $gameVersionFromMainMod"
                  download_link=$(echo "$versionInfo" | jq -r ".downloadUrl")
                  fetch_with_dlink "$download_link" 
                    
                  echo "Checking for inner deps and install if needed"
                  has_req_inner_deps=$(echo "$versionInfo" | jq -r '[.dependencies[] | select(.relationType == 3)] |  length')
                    if [ "$has_req_inner_deps" -gt 0 ]; then
                      echo "Mod with inner deps: $versionInfo"
                      deps=$(echo "$versionInfo" | jq -r "[.dependencies[] | select(.relationType == 3)]")
                      echo "Inner req deps: $deps"

                      echo "$deps" | jq -c '.[]' | while IFS= read -r dep; do
                         process_dependency "$dep" "$gameVersionFromMainMod"
                       done
                     else
                      echo "There IS NO inner deps"
                    fi
                   break
                 else
                   echo "$forgeGameVersion or $gameVersionFromMainMod is not presented, mod not compatible"
                 fi
             done
          }
          source /root/.env
          echo "Base URL: $BASE_URL"
          echo "API_KEY: $API_KEY"
          echo "INPUT_PROJECT_ID: $INPUT_PROJECT_ID"
          echo "INPUT_FILE_ID: $INPUT_FILE_ID"
          
          cd /root/tempMC
            
          api_url_dlink="$BASE_URL/v1/mods/$INPUT_PROJECT_ID/files/$INPUT_FILE_ID/download-url"
          api_url_info="$BASE_URL/v1/mods/$INPUT_PROJECT_ID/files/$INPUT_FILE_ID"

          fetch_with_dlink "$api_url_dlink"

          echo "Install deps if needed"
          curl -L "$api_url_info" -H "x-api-key: $API_KEY" -o /root/temp/response.json

          if [[ -s /root/temp/response.json ]]; then
            echo "Successfully downloaded response.json"
            has_dependencies=$(jq -r '.data.dependencies | length' /root/temp/response.json)
            echo "Has Deps? $has_dependencies"
            
            if [ "$has_dependencies" -gt 0 ]; then
              dep_lvl_req=3
              # dep_lvl_opt=2
              deps=$(jq --argjson dep_lvl_req "$dep_lvl_req" --argjson dep_lvl_opt "$dep_lvl_opt" -r '[.data.dependencies[] | select(.relationType == $dep_lvl_req or .relationType == $dep_lvl_opt)]' /root/temp/response.json )
              gameVersion=$(jq -r '.data.gameVersions[] | select(test("^[0-9]+\\.[0-9]+\\.[0-9]+$"))' /root/temp/response.json)
              echo "Dependencies list: $deps"

              echo "$deps" | jq -c '.[]' | while IFS= read -r dep; do
                process_dependency "$dep" "$gameVersion"
              done
            else
              echo "Has no deps in mod"
            fi
          else
            echo "No information on deps"
          fi
         EOF

      - name: Install all modes from temp and clear temp
        run: |
          ssh -o StrictHostKeyChecking=no root@206.189.84.101 <<'EOF'
            is_excluded_mod() {
              local projectId="$1"
              for excluded_mod in "${excluded_mods_array[@]}"; do
                if [[ "$projectId" == "$excluded_mod" ]]; then
                  return 1
                fi
              done
              return 0
            }
            
            fetch_with_dlink() {
              local url=$1
              
              downloadUrl=$(curl "$url" -H "x-api-key: $API_KEY"" | sed '/HTTP_STATUS:/d' | jq -r '.data')
              echo "Extracted URL: $downloadUrl"

              fileName=$(basename "$downloadUrl")
              echo "fileName: $fileName"
          
              if [[ $downloadUrl =~ ^https?:// ]]; then
                echo "Valid URL: $downloadUrl"
                pathForFile="/root/temp/$fileName"
                curl -o "$pathForFile" -L "$downloadUrl"
                echo "Downloaded dep: $downloadUrl"
              else
                echo "$projectID" >> "$notAccessibleModsFile"
                echo "Some mod cannot be added $projectID. Current list: $(cat $notAccessibleModsFile)"
              fi
            }
            source /root/.env
            echo "Base URL: $BASE_URL"
            echo "API_KEY: $API_KEY"
            echo "INPUT_PROJECT_ID: $INPUT_PROJECT_ID"
            echo "INPUT_FILE_ID: $INPUT_FILE_ID"
            echo "INPUT_EXLUDED_MODS: $INPUT_EXLUDED_MODS"
            
            IFS=',' read -r -a excluded_mods_array <<< "$INPUT_EXLUDED_MODS"

            api_url_dlink="$BASE_URL/v1/mods/$INPUT_PROJECT_ID/files/$INPUT_FILE_ID/download-url"
            notAccessibleModsFile='/root/temp/notAccessible.txt'
            > "$notAccessibleModsFile"
            cd /root/temp/
            
            for file in *.zip; do
              if [ -f "$file" ]; then
                echo "Found archive in folder, trying to unpack and install"
                unzip -o "$file"

                echo "Trying to find manifest.json after unziping"
                if [[-f /root/temp/manifest.json]]; then 
                  echo "There is manifest.json"
                  cat ./manifest.json | jq -c '.files[]' | while IFS= read -r mod ; do
                    echo "$mod"
                    projectID=$(echo "$mod" | jq '.projectID')
                      
                    if is_excluded_mod "$projectID"; then
                      echo "Skipping excluded mod: $projectID"
                    else 
                      echo "Downloading mod for modpack: $projectID"
                      fileId=$(echo "$mod" | jq '.fileID')
                      dyn_api_url="$BASE_URL/v1/mods/$projectID/files/$fileId/download-url"
                  
                      fetch_with_dlink "$dyn_api_url"
                    fi
                  done
                else
                  echo "There is no manifest.json"
                fi
              done 
              cp -r /root/temp/overrides/* /root/tempMC/
             else 
               echo "There is no modpack file"
             fi
            done
            find /root/temp/* -name '*.jar' -exec cp {} /root/tempMC/mods/ \;
            echo "There is some mods that can not be downloaded via API, download them manually. List of mods: $(cat $notAccessibleModsFile)"
            rm -r /root/temp/*
          EOF

      - name: Start server if required
        if: ${{ startsWith(github.event.inputs.start_server, true)  }}
        run: |
          ssh -o StrictHostKeyChecking=no root@206.189.84.101 << 'EOF'
            echo "Running commands on the Droplet"
            cd /root/tempMC
            FILE=$(ls forge* | head -n 1)
            chmod 7 ./$FILE
            java -jar ./$FILE
          EOF
      

    
